------------------------Deploy to Local Docker------------------------

Prerequisites:
-------------
1. Install Docker Desktop:
   - Download from: https://www.docker.com/products/docker-desktop/
   - Verify installation: docker --version
   - Ensure Docker Desktop is running (check system tray icon)

2. Python Environment Setup (for local testing):
   - Python 3.11 or later installed
   - Required packages: flask, gunicorn (listed in requirements.txt)

Local Docker Deployment Steps:
----------------------------
1. Build the Docker Image:
   - Open terminal in project root directory
   - Build command: docker build -t cloud-run-deploy .
   - This will:
     * Use Python 3.11 slim base image
     * Install dependencies from requirements.txt
     * Copy application code
     * Configure Gunicorn server

2. Verify the Build:
   - List images: docker images
   - You should see 'cloud-run-deploy' in the list
   - Check image details: docker inspect cloud-run-deploy

3. Run the Container:
   - Basic run: docker run -p 8080:8080 cloud-run-deploy
   - With environment variables:
     docker run -p 8080:8080 -e PYTHONUNBUFFERED=1 cloud-run-deploy
   - Run in detached mode:
     docker run -d -p 8080:8080 --name cloud-run-deploy cloud-run-deploy

4. Test the Application:
   - Access via browser: http://localhost:8080
   - Expected response: JSON with greeting and hostname
   - Check logs: docker logs cloud-run-deploy
   - Interactive shell: docker exec -it cloud-run-deploy /bin/bash

Container Management:
-------------------
1. View running containers:
   docker ps

2. Stop the container:
   docker stop cloud-run-deploy

3. Remove the container:
   docker rm cloud-run-deploy

4. Remove the image:
   docker rmi cloud-run-deploy

Troubleshooting:
---------------
1. Port conflicts:
   - Error: "port is already allocated"
   - Solution: 
     * Check running containers: docker ps
     * Stop conflicting container or use different port:
       docker run -p 8081:8080 cloud-run-deploy

2. Build failures:
   - Clean Docker cache: docker builder prune
   - Rebuild with no cache: docker build --no-cache -t cloud-run-deploy .

3. Container crashes:
   - Check logs: docker logs cloud-run-deploy
   - Interactive debug: docker run -it cloud-run-deploy /bin/bash
   - Check resource usage: docker stats

Using Docker Compose (Recommended):
-----------------------------
1. Overview:
   - docker-compose.yml is provided for orchestrating containers
   - Includes pre-configured settings for scalability
   - Supports multiple services (web, database, cache, monitoring)
   - Defines resource limits and health checks

2. Basic Docker Compose Commands:
   - Start all services:
     docker-compose up -d
   
   - View logs for all services:
     docker-compose logs -f
     For specific service:
     docker-compose logs -f web

   - Stop all services:
     docker-compose down
     With volumes:
     docker-compose down -v

   - Rebuild and start:
     docker-compose up -d --build

   - Check service status:
     docker-compose ps

3. Development with Docker Compose:
   - Environment variables are configured in docker-compose.yml
   - Resource limits are pre-configured (CPU and Memory)
   - Health checks are implemented for reliability
   - Network isolation is configured via app-network
   - Persistent volumes are defined for data storage

4. Adding New Services:
   - Edit docker-compose.yml
   - Uncomment desired service (db, cache, monitoring)
   - Configure service-specific environment variables
   - Run docker-compose up -d to apply changes

5. Resource Management:
   - CPU and memory limits are predefined
   - Monitor resources: docker-compose top
   - Scale services: docker-compose up -d --scale web=2
     (Note: Adjust ports for scaling)

6. Development Tips:
   - Real-time code changes with volumes:
     Uncomment volume mounts in docker-compose.yml
   - Use docker-compose.override.yml for local-only changes
   - Set DEBUG=1 in environment for development mode

Notes:
------
- The container uses port 8080 internally (configured in Dockerfile)
- Gunicorn is used as the production server
- All logs are directed to stdout/stderr
- The application is stateless and can be safely stopped/started
- Container restarts: Use --restart=always for auto-restart on failure
